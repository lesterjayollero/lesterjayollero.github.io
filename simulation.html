<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Traffic Simulation | Lester Jay Ollero</title>
  <meta name="author" content="Lester Jay Ollero">
  <meta name="keywords" content="Traffic Simulation, Newell, Greenshields, Fundamental Diagram, Flow-Density">

  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css">
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

  <style>
    /* === page theme similar to research.html === */
    body { font-family: "Segoe UI", Roboto, sans-serif; margin:0; background:#fafafa; color:#222; line-height:1.6; }
    a { color:#0077b6; text-decoration:none; }
    .navbar { background:#fff; border-bottom:1px solid #ddd; position:sticky; top:0; z-index:100; }
    .nav-container { display:flex; justify-content:space-between; align-items:center; padding:12px 24px; max-width:1100px; margin:0 auto; }
    .nav-logo { font-size:1.25rem; font-weight:600; color:#003049; }
    .nav-menu { display:flex; list-style:none; gap:12px; margin:0; padding:0; }
    .nav-menu a { color:#003049; font-weight:500; }
    .nav-menu a.active { color:#0077b6; font-weight:600; border-bottom:2px solid #0077b6; padding-bottom:2px; }

    .container { max-width:1100px; margin:30px auto; padding: 0 20px; }
    h1 { color:#003049; font-size:1.8rem; border-bottom:3px solid #0077b6; display:inline-block; padding-bottom:6px; margin-bottom:18px; }

    .controls { display:flex; gap:12px; flex-wrap:wrap; align-items:center; margin:12px 0 18px; }
    .control-group { background:#fff; padding:10px 12px; border-radius:8px; border:1px solid #e6eef7; box-shadow:0 1px 3px rgba(0,0,0,0.03); }
    .control-group label { display:block; font-size:0.9rem; color:#003049; margin-bottom:6px; }
    input[type=range] { width:260px; }
    .small { font-size:0.85rem; color:#555; }

    .main-grid { display:grid; grid-template-columns: 1fr 420px; gap:18px; align-items:start; }
    .panel { background:#fff; border-radius:8px; padding:12px; border:1px solid #eee; box-shadow:0 2px 6px rgba(0,0,0,0.03); }
    canvas.sim { width:100%; height:320px; background:#e9f5ff; border-radius:6px; display:block; }

    .row { display:flex; gap:12px; margin-top:12px; flex-wrap:wrap; }
    .stat { min-width:110px; background:#f8fbff; padding:8px 10px; border-radius:6px; border:1px solid #e2f0ff; text-align:center; }
    .stat h4 { margin:0; font-size:0.8rem; color:#00607f; }
    .stat p { margin:6px 0 0; font-weight:700; font-size:1.15rem; color:#222; }

    footer { text-align:center; margin:30px 0 40px; color:#555; font-size:0.9rem; }

    /* responsive */
    @media (max-width: 980px) {
      .main-grid { grid-template-columns: 1fr; }
      input[type=range] { width:200px; }
    }
  </style>
</head>
<body>
  <!-- navbar -->
  <nav class="navbar">
    <div class="nav-container">
      <a class="nav-logo" href="index.html">Lester Jay Ollero</a>
      <ul class="nav-menu">
        <li><a href="index.html#home">Home</a></li>
        <li><a href="research.html">Research</a></li>
        <li><a class="active" href="simulation.html">Traffic Simulation</a></li>
        <li><a href="publications.html">Publications</a></li>
      </ul>
    </div>
  </nav>

  <div class="container">
    <h1>One-Lane Traffic Simulation (Newell-style) — Greenshields Overlay</h1>

    <p class="small">
      This demo simulates vehicles on a one-lane road with a bottleneck. The Flow–Density scatter from the simulation is now plotted with the
      <strong>Greenshields</strong> theoretical curve (linear speed–density). Adjust inflow and bottleneck to see how simulated points compare to theory.
    </p>

    <!-- controls -->
    <div class="controls">
      <div class="control-group">
        <label>Inflow (veh/hr)</label>
        <input id="inflowSlider" type="range" min="200" max="2400" step="50" value="800">
        <div class="small">Current: <span id="inflowDisplay">800</span> veh/hr</div>
      </div>

      <div class="control-group">
        <label>Bottleneck capacity (veh/hr)</label>
        <input id="bottleCapSlider" type="range" min="200" max="2400" step="50" value="1000">
        <div class="small">Capacity: <span id="bottleCapDisplay">1000</span> veh/hr</div>
      </div>

      <div class="control-group">
        <label>Bottleneck speed (m/s)</label>
        <input id="bottleSpeedSlider" type="range" min="2" max="20" step="0.5" value="6">
        <div class="small">Bottleneck speed: <span id="bottleSpeedDisplay">6.0</span> m/s</div>
      </div>

      <div class="control-group">
        <label>Greenshields</label>
        <div style="display:flex; gap:8px; align-items:center;">
          <input type="checkbox" id="showGreenshields" checked>
          <label for="showGreenshields" class="small">Show Greenshields curve</label>
        </div>
        <div style="margin-top:8px;font-size:0.85rem;color:#444;">
          <div>Estimated v<sub>f</sub> (free speed): <span id="vfDisplay">54.0</span> km/h</div>
          <div>Estimated k<sub>j</sub> (jam density): <span id="kjDisplay">111.1</span> veh/km</div>
        </div>
      </div>

      <div class="control-group">
        <label>Simulation</label>
        <div style="display:flex;gap:8px;">
          <button id="startBtn"><i class="fa-solid fa-play"></i> Start</button>
          <button id="pauseBtn"><i class="fa-solid fa-pause"></i> Pause</button>
          <button id="stepBtn">Step</button>
          <button id="resetBtn"><i class="fa-solid fa-rotate-left"></i> Reset</button>
        </div>
      </div>

      <div class="control-group">
        <label>Additional information</label>
        <div><input type="checkbox" id="showMacros" checked> <label for="showMacros" class="small"> Show macroscopic variables</label></div>
        <div><input type="checkbox" id="showTimeSpace" checked> <label for="showTimeSpace" class="small"> Show time–space trajectories</label></div>
      </div>
    </div>

    <div class="main-grid">
      <!-- left: canvas / visuals -->
      <div class="panel">
        <h3 style="margin:0 0 8px 0; color:#003049;">Simulation view</h3>

        <!-- top: animated road (moving vehicles) -->
        <canvas id="roadCanvas" class="sim" width="800" height="160"></canvas>

        <!-- time-space canvas (trajectories) -->
        <h4 style="margin-top:12px; color:#003049;">Time–space diagram (trajectories)</h4>
        <canvas id="tsCanvas" class="sim" width="800" height="260"></canvas>

        <div class="row" style="margin-top:10px;">
          <div class="stat"><h4>Cumulative count N(t)</h4><p id="cumCount">0</p></div>
          <div class="stat"><h4>Flow q (veh/hr)</h4><p id="flowVal">0</p></div>
          <div class="stat"><h4>Density k (veh/km)</h4><p id="densVal">0</p></div>
          <div class="stat"><h4>Speed v (km/h)</h4><p id="speedVal">0</p></div>
        </div>
      </div>

      <!-- right: charts -->
      <div class="panel">
        <h3 style="margin:0 0 8px 0; color:#003049;">Analytics</h3>
        <p class="small">Charts update as simulation runs. Use "Step" to advance one timestep.</p>

        <h4 style="margin-top:8px;">Cumulative count N–t</h4>
        <canvas id="ntChart" width="380" height="160"></canvas>

        <h4 style="margin-top:12px;">Flow–Density (fundamental diagram)</h4>
        <canvas id="fdChart" width="380" height="160"></canvas>

        <h4 style="margin-top:12px;">Speed–Density</h4>
        <canvas id="sdChart" width="380" height="160"></canvas>

        <div style="margin-top:12px;font-size:0.85rem;color:#444;">
          <strong>Notes:</strong> Greenshields uses v = v<sub>f</sub> (1 - k/k<sub>j</sub>) and q = k v. The curve is plotted using estimated v<sub>f</sub> and k<sub>j</sub>.
        </div>
      </div>
    </div>
  </div>

  <footer>© 2025 Lester Jay Ollero</footer>

<script>
/* =========================
   Simulation parameters (same as before)
   ========================= */
const roadMeters = 2000;           // physical length in meters
const dt = 1.0;                    // time step in seconds
const pxPerMeter = 0.28;           // initial visual scale
const vehicleLength = 6;           // m
const minSpacing = 2;              // m
const jamSpacing = vehicleLength + minSpacing; // m

const freeSpeedDefault = 15;       // m/s (~54 km/h)
let pxPerMeterLocal = 0.28;        // will be adapted to canvas width

let vehicles = [];
let simTime = 0;
let running = false;
let lastId = 0;
let cumulativeCount = 0;
let NtTimes = [], NtCounts = [];

// segments for macroscopic computation
const segments = [
  { name: "upstream", x0: 0, x1: 500 },
  { name: "mid", x0: 500, x1: 1300 },
  { name: "bottleneck", x0: 1300, x1: roadMeters }
];

// Canvas setup
const roadCanvas = document.getElementById('roadCanvas');
const roadCtx = roadCanvas.getContext('2d');
const tsCanvas = document.getElementById('tsCanvas');
const tsCtx = tsCanvas.getContext('2d');

function adaptCanvases() {
  const containerWidth = Math.min(900, window.innerWidth - 80);
  const w = Math.max(700, containerWidth);
  roadCanvas.width = w;
  tsCanvas.width = w;
  // adjust px per meter to fill canvas width
  pxPerMeterLocal = w / roadMeters;
}
adaptCanvases();
window.addEventListener('resize', () => { adaptCanvases(); drawStaticRoad(); drawTimeSpace(); });

/* Controls */
const inflowSlider = document.getElementById('inflowSlider');
const bottleCapSlider = document.getElementById('bottleCapSlider');
const bottleSpeedSlider = document.getElementById('bottleSpeedSlider');
const inflowDisplay = document.getElementById('inflowDisplay');
const bottleCapDisplay = document.getElementById('bottleCapDisplay');
const bottleSpeedDisplay = document.getElementById('bottleSpeedDisplay');
const showGreenshields = document.getElementById('showGreenshields');
const vfDisplay = document.getElementById('vfDisplay');
const kjDisplay = document.getElementById('kjDisplay');

inflowDisplay.textContent = inflowSlider.value;
bottleCapDisplay.textContent = bottleCapSlider.value;
bottleSpeedDisplay.textContent = parseFloat(bottleSpeedSlider.value).toFixed(1);

/* Chart.js setup */
const ntCtx = document.getElementById('ntChart').getContext('2d');
const fdCtx = document.getElementById('fdChart').getContext('2d');
const sdCtx = document.getElementById('sdChart').getContext('2d');

const ntChart = new Chart(ntCtx, {
  type: 'line',
  data: { labels: [], datasets:[{ label:'N(t) downstream', data:[], borderColor:'#0077b6', fill:false, tension:0.2 }]},
  options: { responsive:true, plugins:{ legend:{display:false} }, scales:{ x:{title:{display:true,text:'Time (s)'}}, y:{title:{display:true,text:'Cumulative count (veh)'}}}}
});

const fdScatter = new Chart(fdCtx, {
  type: 'scatter',
  data: { datasets: [
    { label:'Simulation (segments)', data:[], backgroundColor:'#00607f' },
    { label:'Greenshields', data:[], borderColor:'#ff7f0e', showLine:true, fill:false, pointRadius:0, tension:0.25 }
  ]},
  options: { responsive:true, plugins:{ legend:{display:true} }, scales:{ x:{title:{display:true,text:'Density (veh/km)'}}, y:{title:{display:true,text:'Flow (veh/hr)'}}}}
});

const sdScatter = new Chart(sdCtx, {
  type:'scatter',
  data: { datasets: [{ label:'Speed vs Density', data:[], backgroundColor:'#c44b4b' }]},
  options: { responsive:true, plugins:{ legend:{display:false} }, scales:{ x:{title:{display:true,text:'Density (veh/km)'}}, y:{title:{display:true,text:'Speed (km/h)'}}}}
});

/* utility */
function metersToPx(m){ return m * pxPerMeterLocal; }
function randomProb(p){ return Math.random() < p; }

/* insertion */
function tryInsertVehicle() {
  const inflow = Number(inflowSlider.value);
  const p = (inflow/3600) * dt;
  // ensure spacing at upstream (check nearest vehicle near x<=50)
  const firstVeh = vehicles.length ? vehicles[vehicles.length - 1] : null;
  const canInsert = !firstVeh || (firstVeh.x > jamSpacing + 2);
  if (randomProb(p) && canInsert) {
    const v0 = freeSpeedDefault;
    const veh = { id: ++lastId, x: 0 - vehicleLength, v: v0, history: [ {t:simTime, x: 0 - vehicleLength} ], insertTime: simTime };
    vehicles.push(veh);
  }
}

/* bottleneck params */
function getBottleneckParams(){
  const bnStart = 1300;
  const bSpeed = Number(bottleSpeedSlider.value);
  const bCap = Number(bottleCapSlider.value);
  return { bnStart, bSpeed, bCap };
}

/* step update: Newell-like */
function stepOnce(){
  simTime += dt;
  tryInsertVehicle();
  vehicles.sort((a,b)=>a.x - b.x);

  const { bnStart, bSpeed, bCap } = getBottleneckParams();
  if (typeof stepOnce.lastPassTime === 'undefined') stepOnce.lastPassTime = -1e9;
  const minHeadwayDown = 3600 / bCap;

  for (let i=0;i<vehicles.length;i++){
    const veh = vehicles[i];
    let leader = null;
    for (let j=i+1;j<vehicles.length;j++){ if (vehicles[j].x > veh.x) { leader = vehicles[j]; break; } }

    let v_free = freeSpeedDefault;
    if (veh.x >= bnStart) v_free = Math.min(v_free, bSpeed);

    let xCand = veh.x + v_free * dt;

    if (leader) {
      const maxX = leader.x - jamSpacing;
      if (xCand > maxX) xCand = maxX;
    }

    if (xCand >= roadMeters - 0.1) {
      if (simTime - stepOnce.lastPassTime < minHeadwayDown) {
        xCand = roadMeters - jamSpacing - 0.01;
      } else {
        stepOnce.lastPassTime = simTime;
        cumulativeCount += 1;
        NtTimes.push(simTime);
        NtCounts.push(cumulativeCount);
      }
    }

    const oldX = veh.x;
    veh.x = xCand;
    veh.v = (veh.x - oldX) / dt;
    veh.history.push({t:simTime, x:veh.x});
    if (veh.history.length > 10000) veh.history.shift();
  }

  vehicles = vehicles.filter(v => v.x < roadMeters + 50);

  // sample cumulative at every second
  if (NtTimes.length === 0 || NtTimes[NtTimes.length-1] !== simTime) {
    NtTimes.push(simTime);
    NtCounts.push(cumulativeCount);
  }
}

/* macros */
function computeMacros(){
  const windowSec = 30;
  const now = simTime;
  const t0 = now - windowSec;
  let idx0 = 0;
  while (idx0 < NtTimes.length && NtTimes[idx0] <= t0) idx0++;
  const countAtT0 = (idx0>0)? NtCounts[idx0-1] : 0;
  const countNow = NtCounts.length ? NtCounts[NtCounts.length-1] : 0;
  const flowDown = (countNow - countAtT0) / (windowSec/3600);

  const segMacros = segments.map(seg => {
    const vehiclesInSeg = vehicles.filter(v => v.x >= seg.x0 && v.x < seg.x1);
    const lenKm = (seg.x1 - seg.x0) / 1000;
    const density = vehiclesInSeg.length / (lenKm || 1e-6);
    const avgSpeedMs = vehiclesInSeg.length ? (vehiclesInSeg.reduce((s,v)=>s+v.v,0) / vehiclesInSeg.length) : 0;
    const avgSpeedKmh = avgSpeedMs * 3.6;
    return { name: seg.name, density, avgSpeedKmh, count: vehiclesInSeg.length, lenKm };
  });

  const totalLenKm = roadMeters / 1000;
  const totalDensity = vehicles.length / totalLenKm;
  const avgSpeedAllMs = vehicles.length ? vehicles.reduce((s,v)=>s+v.v,0)/vehicles.length : 0;
  const avgSpeedAllKmh = avgSpeedAllMs * 3.6;

  return { flowDown, segMacros, totalDensity, avgSpeedAllKmh };
}

/* drawing */
function drawStaticRoad(){
  const ctx = roadCtx;
  const w = roadCanvas.width, h = roadCanvas.height;
  ctx.clearRect(0,0,w,h);
  ctx.fillStyle = "#dfefff";
  ctx.fillRect(0,0,w,h);

  const roadY = h/2 - 22;
  const roadH = 44;
  ctx.fillStyle = "#9fb3c8";
  ctx.fillRect(0, roadY, w, roadH);

  ctx.strokeStyle = "#fff";
  ctx.setLineDash([16,10]);
  ctx.lineWidth = 3;
  ctx.beginPath(); ctx.moveTo(0, roadY + roadH/2); ctx.lineTo(w, roadY + roadH/2); ctx.stroke();
  ctx.setLineDash([]);

  const { bnStart } = getBottleneckParams();
  const bnPx = metersToPx(bnStart);
  ctx.fillStyle = "rgba(200,100,100,0.12)";
  ctx.fillRect(bnPx, roadY, w - bnPx, roadH);
  ctx.fillStyle = "rgba(200,100,100,0.25)";
  ctx.font = "12px Arial";
  ctx.fillText("Bottleneck region", Math.max(bnPx + 6, 6), roadY + 14);
}

function drawVehicles(){
  const ctx = roadCtx;
  const h = roadCanvas.height;
  const roadY = h/2 - 22;

  vehicles.forEach(v => {
    const px = metersToPx(v.x);
    const vehW = Math.max(6, vehicleLength * pxPerMeterLocal);
    const vehH = 16;
    ctx.fillStyle = "#0b486b";
    ctx.fillRect(px, roadY + (44-vehH)/2, vehW, vehH);
    ctx.fillStyle = "#fff";
    ctx.fillRect(px + vehW*0.12, roadY + (44-vehH)/2 + 3, vehW*0.35, 6);
  });
}

function drawTimeSpace(){
  const ctx = tsCtx;
  const w = tsCanvas.width, h = tsCanvas.height;
  ctx.clearRect(0,0,w,h);
  ctx.fillStyle = "#fcfeff";
  ctx.fillRect(0,0,w,h);

  ctx.strokeStyle = "#ddd";
  ctx.strokeRect(40,10,w-50,h-40);

  ctx.fillStyle = "#003049";
  ctx.font = "12px Arial";
  ctx.fillText("t (s)", w - 30, h - 18);
  ctx.fillText("x (m)", 6, 20);

  const tWindow = 200;
  const t0 = Math.max(0, simTime - tWindow);
  const plotX = (time)=> { return 40 + ((time - t0) / tWindow) * (w - 90); };
  const plotY = (x)=> { return 10 + (1 - x/roadMeters) * (h - 60); };

  if (document.getElementById('showTimeSpace').checked) {
    vehicles.forEach(v => {
      const hist = v.history.filter(p => p.t >= t0);
      if (hist.length < 2) return;
      ctx.beginPath();
      const hue = (v.id * 37) % 360;
      ctx.strokeStyle = `hsl(${hue},60%,35%)`;
      ctx.lineWidth = 1.6;
      for (let i=0;i<hist.length;i++){
        const p = hist[i];
        const px = plotX(p.t);
        const py = plotY(p.x);
        if (i===0) ctx.moveTo(px, py); else ctx.lineTo(px, py);
      }
      ctx.stroke();
    });
  } else {
    ctx.fillStyle = "#eee";
    ctx.fillRect(45,15, w-100, h-60);
  }

  ctx.fillStyle = "#003049";
  ctx.fillText("t = " + Math.floor(simTime) + " s", w - 120, 20);
}

/* charts & stats update including Greenshields */
function updateChartsAndStats(){
  const macros = computeMacros();

  document.getElementById('cumCount').textContent = cumulativeCount;
  document.getElementById('flowVal').textContent = Math.round(macros.flowDown);
  document.getElementById('densVal').textContent = (macros.totalDensity).toFixed(1);
  document.getElementById('speedVal').textContent = (macros.avgSpeedAllKmh).toFixed(1);

  // N-t
  ntChart.data.labels = NtTimes.slice(-200);
  ntChart.data.datasets[0].data = NtCounts.slice(-200);
  ntChart.update('none');

  // FD: use segment points
  const fdPoints = [];
  macros.segMacros.forEach(s => {
    fdPoints.push({ x: s.density, y: macros.flowDown });
  });
  fdScatter.data.datasets[0].data = fdPoints;

  // Greenshields: compute v_f (km/h) and kj (veh/km)
  const vf_kmh = freeSpeedDefault * 3.6;                    // m/s -> km/h
  const kj = 1000 / jamSpacing;                             // veh/km
  vfDisplay.textContent = vf_kmh.toFixed(1);
  kjDisplay.textContent = kj.toFixed(1);

  if (showGreenshields.checked) {
    // generate smooth curve
    const n = 120;
    const curve = [];
    for (let i=0;i<=n;i++){
      const k = (i/n) * kj;
      const v = vf_kmh * (1 - (k / kj));     // Greenshields v(k) linear
      const q = k * v;                       // q = k * v
      curve.push({ x: k, y: q });
    }
    fdScatter.data.datasets[1].data = curve;
    fdScatter.data.datasets[1].hidden = false;
  } else {
    fdScatter.data.datasets[1].data = [];
    fdScatter.data.datasets[1].hidden = true;
  }
  fdScatter.update('none');

  // Speed-density chart from segments
  const sdPoints = macros.segMacros.map(s => ({ x: s.density, y: s.avgSpeedKmh }));
  sdScatter.data.datasets[0].data = sdPoints;
  sdScatter.update('none');
}

/* main loop */
function stepSim(){
  stepOnce();
  drawStaticRoad();
  drawVehicles();
  drawTimeSpace();
  updateChartsAndStats();
}

function runSim(){
  if (!running) return;
  stepSim();
  setTimeout(()=> { if (running) requestAnimationFrame(runSim); }, 1000 * (dt/1.0));
}

/* controls wiring */
inflowSlider.addEventListener('input', ()=> inflowDisplay.textContent = inflowSlider.value);
bottleCapSlider.addEventListener('input', ()=> bottleCapDisplay.textContent = bottleCapSlider.value);
bottleSpeedSlider.addEventListener('input', ()=> bottleSpeedDisplay.textContent = parseFloat(bottleSpeedSlider.value).toFixed(1));

document.getElementById('startBtn').addEventListener('click', ()=> { running = true; runSim(); });
document.getElementById('pauseBtn').addEventListener('click', ()=> { running = false; });
document.getElementById('resetBtn').addEventListener('click', ()=> { resetSim(); });
document.getElementById('stepBtn').addEventListener('click', ()=> { stepSim(); });
showGreenshields.addEventListener('change', ()=> updateChartsAndStats());

/* reset */
function resetSim(){
  vehicles = [];
  simTime = 0;
  cumulativeCount = 0;
  NtTimes = []; NtCounts = [];
  lastId = 0;
  stepOnce.lastPassTime = -1e9;
  // warm vehicles
  for (let i=0;i<6;i++){
    vehicles.push({ id: ++lastId, x: i*40 + 20, v: freeSpeedDefault, history: [{t:0,x:i*40+20}] });
  }
  drawStaticRoad();
  drawVehicles();
  drawTimeSpace();
  updateChartsAndStats();
}

/* initialize */
resetSim();
drawStaticRoad();
drawVehicles();
drawTimeSpace();
updateChartsAndStats();

</script>
</body>
</html>
