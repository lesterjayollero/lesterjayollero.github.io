<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Traffic Simulation | Lester Jay Ollero</title>
  <meta name="author" content="Lester Jay Ollero">
  <meta name="keywords" content="Traffic Simulation, Newell, Time-space, Flow-Density, Cumulative count">

  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css">
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

  <style>
    /* === page theme similar to research.html === */
    body { font-family: "Segoe UI", Roboto, sans-serif; margin:0; background:#fafafa; color:#222; line-height:1.6; }
    a { color:#0077b6; text-decoration:none; }
    .navbar { background:#fff; border-bottom:1px solid #ddd; position:sticky; top:0; z-index:100; }
    .nav-container { display:flex; justify-content:space-between; align-items:center; padding:12px 24px; max-width:1100px; margin:0 auto; }
    .nav-logo { font-size:1.25rem; font-weight:600; color:#003049; }
    .nav-menu { display:flex; list-style:none; gap:12px; margin:0; padding:0; }
    .nav-menu a { color:#003049; font-weight:500; }
    .nav-menu a.active { color:#0077b6; font-weight:600; border-bottom:2px solid #0077b6; padding-bottom:2px; }

    .container { max-width:1100px; margin:30px auto; padding: 0 20px; }
    h1 { color:#003049; font-size:1.8rem; border-bottom:3px solid #0077b6; display:inline-block; padding-bottom:6px; margin-bottom:18px; }

    .controls { display:flex; gap:12px; flex-wrap:wrap; align-items:center; margin:12px 0 18px; }
    .control-group { background:#fff; padding:10px 12px; border-radius:8px; border:1px solid #e6eef7; box-shadow:0 1px 3px rgba(0,0,0,0.03); }
    .control-group label { display:block; font-size:0.9rem; color:#003049; margin-bottom:6px; }
    input[type=range] { width:260px; }
    .small { font-size:0.85rem; color:#555; }

    .main-grid { display:grid; grid-template-columns: 1fr 420px; gap:18px; align-items:start; }
    .panel { background:#fff; border-radius:8px; padding:12px; border:1px solid #eee; box-shadow:0 2px 6px rgba(0,0,0,0.03); }
    canvas.sim { width:100%; height:320px; background:#e9f5ff; border-radius:6px; display:block; }

    .row { display:flex; gap:12px; margin-top:12px; flex-wrap:wrap; }
    .stat { min-width:110px; background:#f8fbff; padding:8px 10px; border-radius:6px; border:1px solid #e2f0ff; text-align:center; }
    .stat h4 { margin:0; font-size:0.8rem; color:#00607f; }
    .stat p { margin:6px 0 0; font-weight:700; font-size:1.15rem; color:#222; }

    footer { text-align:center; margin:30px 0 40px; color:#555; font-size:0.9rem; }

    /* responsive */
    @media (max-width: 980px) {
      .main-grid { grid-template-columns: 1fr; }
      input[type=range] { width:200px; }
    }
  </style>
</head>
<body>
  <!-- navbar -->
  <nav class="navbar">
    <div class="nav-container">
      <a class="nav-logo" href="index.html">Lester Jay Ollero</a>
      <ul class="nav-menu">
        <li><a href="index.html#home">Home</a></li>
        <li><a href="research.html">Research</a></li>
        <li><a class="active" href="simulation.html">Traffic Simulation</a></li>
        <li><a href="publications.html">Publications</a></li>
      </ul>
    </div>
  </nav>

  <div class="container">
    <h1>One-Lane Traffic Simulation (Newell-style) — Bottleneck & Fundamental Diagram</h1>

    <p class="small">
      Vehicular traffic flow on a one-lane road segment is simulated using a discrete Newell-style car-following update.
      The road contains a bottleneck region (reduced free speed). If inflow exceeds bottleneck capacity, congestion forms.
      Use the controls below to change inflow and bottleneck impact. Check "Additional info" to compute macroscopic variables.
    </p>

    <!-- controls -->
    <div class="controls">
      <div class="control-group">
        <label>Inflow (veh/hr)</label>
        <input id="inflowSlider" type="range" min="200" max="2400" step="50" value="800">
        <div class="small">Current: <span id="inflowDisplay">800</span> veh/hr</div>
      </div>

      <div class="control-group">
        <label>Bottleneck capacity (veh/hr)</label>
        <input id="bottleCapSlider" type="range" min="200" max="2400" step="50" value="1000">
        <div class="small">Capacity: <span id="bottleCapDisplay">1000</span> veh/hr</div>
      </div>

      <div class="control-group">
        <label>Bottleneck strength (reduced speed m/s)</label>
        <input id="bottleSpeedSlider" type="range" min="2" max="20" step="0.5" value="6">
        <div class="small">Bottleneck speed: <span id="bottleSpeedDisplay">6.0</span> m/s</div>
      </div>

      <div class="control-group">
        <label>Simulation</label>
        <div style="display:flex;gap:8px;">
          <button id="startBtn"><i class="fa-solid fa-play"></i> Start</button>
          <button id="pauseBtn"><i class="fa-solid fa-pause"></i> Pause</button>
          <button id="stepBtn">Step</button>
          <button id="resetBtn"><i class="fa-solid fa-rotate-left"></i> Reset</button>
        </div>
      </div>

      <div class="control-group">
        <label>Additional information</label>
        <div><input type="checkbox" id="showMacros" checked> <label for="showMacros" class="small"> Show macroscopic variables</label></div>
        <div><input type="checkbox" id="showTimeSpace" checked> <label for="showTimeSpace" class="small"> Show time–space trajectories</label></div>
      </div>
    </div>

    <div class="main-grid">
      <!-- left: canvas / visuals -->
      <div class="panel">
        <h3 style="margin:0 0 8px 0; color:#003049;">Simulation view</h3>

        <!-- top: animated road (moving vehicles) -->
        <canvas id="roadCanvas" class="sim" width="800" height="160"></canvas>

        <!-- time-space canvas (trajectories) -->
        <h4 style="margin-top:12px; color:#003049;">Time–space diagram (trajectories)</h4>
        <canvas id="tsCanvas" class="sim" width="800" height="260"></canvas>

        <div class="row" style="margin-top:10px;">
          <div class="stat"><h4>Cumulative count N(t)</h4><p id="cumCount">0</p></div>
          <div class="stat"><h4>Flow q (veh/hr)</h4><p id="flowVal">0</p></div>
          <div class="stat"><h4>Density k (veh/km)</h4><p id="densVal">0</p></div>
          <div class="stat"><h4>Speed v (km/h)</h4><p id="speedVal">0</p></div>
        </div>
      </div>

      <!-- right: charts -->
      <div class="panel">
        <h3 style="margin:0 0 8px 0; color:#003049;">Analytics</h3>
        <p class="small">Charts update as simulation runs. Use "Step" to advance one timestep.</p>

        <h4 style="margin-top:8px;">Cumulative count N–t</h4>
        <canvas id="ntChart" width="380" height="160"></canvas>

        <h4 style="margin-top:12px;">Flow–Density (fundamental diagram)</h4>
        <canvas id="fdChart" width="380" height="160"></canvas>

        <h4 style="margin-top:12px;">Speed–Density</h4>
        <canvas id="sdChart" width="380" height="160"></canvas>

        <div style="margin-top:12px;font-size:0.85rem;color:#444;">
          <strong>Notes:</strong> The fundamental diagram arises from many simulated realizations. Bottleneck reduces local speed (and capacity); if inflow > bottleneck capacity, congestion forms upstream.
        </div>
      </div>
    </div>
  </div>

  <footer>© 2025 Lester Jay Ollero</footer>

<script>
/* =========================
   Simulation parameters
   ========================= */
const roadMeters = 2000;           // physical length in meters (mapping to canvas)
const dt = 1.0;                    // time step in seconds
const simStepSec = dt;
const pxPerMeter = 0.28;           // visual scale (meters -> pixels)
const roadPx = Math.floor(roadMeters * pxPerMeter); // canvas width in px (we will scale)
const insertionX = 0;              // vehicles inserted at x=0 (left)
const downstreamX = roadMeters;    // downstream detector at road end

// Newell-like parameters
const vehicleLength = 6;           // vehicle length (m)
const minSpacing = 2;              // standstill spacing (m)
const jamSpacing = vehicleLength + minSpacing;

const freeSpeedDefault = 15;       // free-flow speed m/s (~54 km/h)
const maxSpeed = 30;               // m/s cap

// arrays & state
let vehicles = [];                 // each vehicle: {id, x (m), t0, history: [{t,x}], v (m/s)}
let simTime = 0;                   // seconds
let running = false;
let lastId = 0;

// cumulative count (N-t)
let cumulativeCount = 0;
let NtTimes = [];
let NtCounts = [];

// detectors/segmentation for macroscopic variables
const segments = [
  { name: "upstream", x0: 0, x1: 500 },
  { name: "mid", x0: 500, x1: 1300 },
  { name: "bottleneck", x0: 1300, x1: roadMeters }
];

// Canvas elements
const roadCanvas = document.getElementById('roadCanvas');
const roadCtx = roadCanvas.getContext('2d');
const tsCanvas = document.getElementById('tsCanvas');
const tsCtx = tsCanvas.getContext('2d');

// adapt canvas widths to visual road size
function adaptCanvases() {
  const containerWidth = Math.min(900, window.innerWidth - 80);
  // compute scale to map our roadMeters -> canvas width
  const w = Math.max(700, containerWidth);
  // set canvas widths while keeping heights
  roadCanvas.width = w;
  tsCanvas.width = w;
  // set global scale: px per meter adjusted
  pxPerMeterLocal = w / roadMeters;
}
let pxPerMeterLocal = 0.28;
adaptCanvases();
window.addEventListener('resize', () => { adaptCanvases(); drawStaticRoad(); drawTimeSpace(); });

// controls
const inflowSlider = document.getElementById('inflowSlider');
const bottleCapSlider = document.getElementById('bottleCapSlider');
const bottleSpeedSlider = document.getElementById('bottleSpeedSlider');
const inflowDisplay = document.getElementById('inflowDisplay');
const bottleCapDisplay = document.getElementById('bottleCapDisplay');
const bottleSpeedDisplay = document.getElementById('bottleSpeedDisplay');

inflowDisplay.textContent = inflowSlider.value;
bottleCapDisplay.textContent = bottleCapSlider.value;
bottleSpeedDisplay.textContent = parseFloat(bottleSpeedSlider.value).toFixed(1);

inflowSlider.addEventListener('input', ()=> inflowDisplay.textContent = inflowSlider.value);
bottleCapSlider.addEventListener('input', ()=> bottleCapDisplay.textContent = bottleCapSlider.value);
bottleSpeedSlider.addEventListener('input', ()=> bottleSpeedDisplay.textContent = parseFloat(bottleSpeedSlider.value).toFixed(1));

document.getElementById('startBtn').addEventListener('click', ()=> { running = true; runSim(); });
document.getElementById('pauseBtn').addEventListener('click', ()=> { running = false; });
document.getElementById('resetBtn').addEventListener('click', ()=> { resetSim(); });
document.getElementById('stepBtn').addEventListener('click', ()=> { stepSim(); });

/* =========================
   Charts (Chart.js)
   ========================= */
const ntCtx = document.getElementById('ntChart').getContext('2d');
const fdCtx = document.getElementById('fdChart').getContext('2d');
const sdCtx = document.getElementById('sdChart').getContext('2d');

const ntChart = new Chart(ntCtx, {
  type: 'line',
  data: { labels: [], datasets:[{ label:'N(t) downstream', data:[], borderColor:'#0077b6', fill:false, tension:0.2 }]},
  options: { responsive:true, plugins:{ legend:{display:false} }, scales:{ x:{title:{display:true,text:'Time (s)'}}, y:{title:{display:true,text:'Cumulative count (veh)'}}}}
});

const fdScatter = new Chart(fdCtx, {
  type: 'scatter',
  data: { datasets: [
    { label:'Flow vs Density', data:[], backgroundColor:'#00607f' }
  ]},
  options: { responsive:true, plugins:{ legend:{display:false} }, scales:{ x:{title:{display:true,text:'Density (veh/km)'}}, y:{title:{display:true,text:'Flow (veh/hr)'}}}}
});

const sdScatter = new Chart(sdCtx, {
  type:'scatter',
  data: { datasets: [{ label:'Speed vs Density', data:[], backgroundColor:'#c44b4b' }]},
  options: { responsive:true, plugins:{ legend:{display:false} }, scales:{ x:{title:{display:true,text:'Density (veh/km)'}}, y:{title:{display:true,text:'Speed (km/h)'}}}}
});

/* =========================
   Utility functions
   ========================= */
function metersToPx(m) { return m * pxPerMeterLocal; }
function pxToMeters(px) { return px / pxPerMeterLocal; }
function randomProb(p) { return Math.random() < p; }

/* =========================
   Inject / move vehicles
   ========================= */
function tryInsertVehicle() {
  // inflowSlider value in veh/hr -> per second probability p = (veh/hr)/3600 * dt
  const inflow = Number(inflowSlider.value);
  const p = (inflow/3600) * dt;
  // ensure spacing at upstream
  const firstVeh = vehicles.length ? vehicles[vehicles.length - 1] : null; // vehicles sorted by x increasing
  const canInsert = !firstVeh || (firstVeh.x > jamSpacing + 2);
  if (randomProb(p) && canInsert) {
    const v0 = freeSpeedDefault; // free speed
    const veh = { id: ++lastId, x: 0 - vehicleLength, v: v0, history: [ {t:simTime, x: 0 - vehicleLength} ], insertTime: simTime };
    vehicles.push(veh);
  }
}

/* =========================
   Bottleneck behavior
   We implement bottleneck as a reduced free speed region and an effective capacity.
   If a vehicle is inside the bottleneck x >= bnStart, its free speed is min(freeSpeed, bottleSpeed)
   Additionally, we enforce a capacity by preventing crossings at a rate exceeding capacity: we keep a small queue counter.
   ========================= */
function getBottleneckParams() {
  const bnStart = 1300;   // start meter of bottleneck
  const bnEnd = roadMeters;
  const bSpeed = Number(bottleSpeedSlider.value);   // m/s (reduced free speed)
  const bCap = Number(bottleCapSlider.value);       // veh/hr
  return { bnStart, bnEnd, bSpeed, bCap };
}

/* =========================
   Single step update (Newell-like)
   Discrete time update: x_i(t+dt) = min( x_i(t) + v_free*dt, x_{i-1}(t) - jamSpacing )
   v_i is computed as (x_new - x_old)/dt
   ========================= */
function stepOnce() {
  simTime += dt;
  // 1) possibly insert
  tryInsertVehicle();

  // sort vehicles by x ascending
  vehicles.sort((a,b) => a.x - b.x);

  const { bnStart, bnEnd, bSpeed, bCap } = getBottleneckParams();

  // We'll implement a simple capacity limiter at the downstream boundary:
  // track last passage time of downstream; ensure rate <= capacity
  if (typeof stepOnce.lastPassTime === 'undefined') stepOnce.lastPassTime = -1e9; // init
  const minHeadwayDown = 3600 / bCap; // seconds per vehicle (if bCap=1000 veh/hr -> 3.6 s)
  // iterate vehicles from upstream -> downstream (increasing x)
  for (let i = 0; i < vehicles.length; i++) {
    const veh = vehicles[i];
    // leader is the next vehicle with x > veh.x (since sorted ascending)
    let leader = null;
    for (let j = i+1; j < vehicles.length; j++) { if (vehicles[j].x > veh.x) { leader = vehicles[j]; break; } }

    // free speed depends on whether vehicle is in bottleneck region
    let v_free = freeSpeedDefault;
    if (veh.x >= bnStart) v_free = Math.min(v_free, bSpeed);

    // candidate new position if unconstrained
    let xCand = veh.x + v_free * dt;

    // constraint due to leader (jam spacing)
    if (leader) {
      const maxX = leader.x - jamSpacing;
      if (xCand > maxX) xCand = maxX;
    }

    // constraint at downstream boundary (simulate capacity)
    if (xCand >= downstreamX - 0.1) {
      // check last passage time
      if (simTime - stepOnce.lastPassTime < minHeadwayDown) {
        // cannot exit yet: keep upstream of downstream boundary
        xCand = downstreamX - jamSpacing - 0.01;
      } else {
        // vehicle will exit: this is a passage
        stepOnce.lastPassTime = simTime;
        cumulativeCount += 1;
        NtTimes.push(simTime);
        NtCounts.push(cumulativeCount);
      }
    }

    // final assignment and update velocity
    const oldX = veh.x;
    veh.x = xCand;
    veh.v = (veh.x - oldX) / dt;
    veh.history.push({ t: simTime, x: veh.x });

    // remove history older than some horizon to limit memory (keep for time-space)
    if (veh.history.length > 10000) veh.history.shift();
  }

  // remove vehicles that have gone beyond downstream sufficiently
  vehicles = vehicles.filter(v => v.x < downstreamX + 50);

  // record N-t even if no passage (sample every 1s)
  if (NtTimes.length === 0 || NtTimes[NtTimes.length-1] !== simTime) {
    NtTimes.push(simTime);
    NtCounts.push(cumulativeCount);
  }
}

/* =========================
   Macroscopic variables (computed per second)
   - We compute for entire road or per segments as selected
   - density (veh/km): count in segment / length_km
   - flow (veh/hr): # vehicles passing downstream in last window / (window_hours)
   - speed (km/h): average speed of vehicles in segment
   ========================= */
function computeMacros() {
  const windowSec = 30; // smoothing window for flow measurement
  const now = simTime;

  // compute flow at downstream: count of vehicles that passed in last window
  // use NtTimes/NtCounts
  let flowDown = 0;
  // find counts at time now-windowSec and now
  const t0 = now - windowSec;
  // find index of first time > t0
  let idx0 = 0;
  while (idx0 < NtTimes.length && NtTimes[idx0] <= t0) idx0++;
  const countAtT0 = (idx0>0) ? NtCounts[idx0-1] : 0;
  const countNow = NtCounts.length ? NtCounts[NtCounts.length-1] : 0;
  flowDown = (countNow - countAtT0) / (windowSec/3600); // veh/hr

  // density & speed per segment (we also compute overall)
  const segMacros = segments.map(seg => {
    const vehiclesInSeg = vehicles.filter(v => v.x >= seg.x0 && v.x < seg.x1);
    const lenKm = (seg.x1 - seg.x0) / 1000;
    const density = vehiclesInSeg.length / (lenKm || 1e-6); // veh/km
    const avgSpeedMs = vehiclesInSeg.length ? (vehiclesInSeg.reduce((s,v)=>s+v.v,0) / vehiclesInSeg.length) : 0;
    const avgSpeedKmh = avgSpeedMs * 3.6;
    return { name:seg.name, density, avgSpeedKmh, count: vehiclesInSeg.length, lenKm };
  });

  // overall metrics (entire road)
  const totalLenKm = roadMeters / 1000;
  const totalDensity = vehicles.length / totalLenKm;
  const avgSpeedAllMs = vehicles.length ? vehicles.reduce((s,v)=>s+v.v,0)/vehicles.length : 0;
  const avgSpeedAllKmh = avgSpeedAllMs * 3.6;

  return { flowDown, segMacros, totalDensity, avgSpeedAllKmh };
}

/* =========================
   Drawing functions
   ========================= */
function drawStaticRoad() {
  const ctx = roadCtx;
  const w = roadCanvas.width, h = roadCanvas.height;
  ctx.clearRect(0,0,w,h);
  // draw road background
  ctx.fillStyle = "#dfefff";
  ctx.fillRect(0, 0, w, h);
  // draw pavement
  ctx.fillStyle = "#9fb3c8";
  const roadY = h/2 - 22;
  const roadH = 44;
  ctx.fillRect(0, roadY, w, roadH);
  // draw center line
  ctx.strokeStyle = "#fff";
  ctx.setLineDash([16, 10]);
  ctx.lineWidth = 3;
  ctx.beginPath(); ctx.moveTo(0, roadY+roadH/2); ctx.lineTo(w, roadY+roadH/2); ctx.stroke();
  ctx.setLineDash([]);

  // mark bottleneck region
  const { bnStart } = getBottleneckParams();
  const bnPx = metersToPx(bnStart);
  ctx.fillStyle = "rgba(200,100,100,0.12)";
  ctx.fillRect(bnPx, roadY, w - bnPx, roadH);
  ctx.fillStyle = "rgba(200,100,100,0.25)";
  ctx.font = "12px Arial";
  ctx.fillText("Bottleneck region", Math.max(bnPx + 6, 6), roadY + 14);
}

function drawVehicles() {
  const ctx = roadCtx;
  const h = roadCanvas.height;
  const roadY = h/2 - 22;
  // draw each vehicle as a rectangle
  vehicles.forEach(v => {
    const px = metersToPx(v.x);
    const vehW = Math.max(6, vehicleLength * pxPerMeterLocal);
    const vehH = 16;
    ctx.fillStyle = "#0b486b";
    ctx.fillRect(px, roadY + (44-vehH)/2, vehW, vehH);
    // small white windows or id
    ctx.fillStyle = "#fff";
    ctx.fillRect(px + vehW*0.12, roadY + (44-vehH)/2 + 3, vehW*0.35, 6);
  });
}

function drawTimeSpace() {
  const ctx = tsCtx;
  const w = tsCanvas.width, h = tsCanvas.height;
  ctx.clearRect(0,0,w,h);
  // background
  ctx.fillStyle = "#fcfeff";
  ctx.fillRect(0,0,w,h);

  // axes: x = time, y = space (distance along road)
  ctx.strokeStyle = "#ddd";
  ctx.strokeRect(40,10,w-50,h-40);

  // labels
  ctx.fillStyle = "#003049";
  ctx.font = "12px Arial";
  ctx.fillText("t (s)", w - 30, h - 18);
  ctx.fillText("x (m)", 6, 20);

  // draw trajectories: for each vehicle, draw lines connecting (t,x)
  const tWindow = 200; // seconds shown
  const t0 = Math.max(0, simTime - tWindow);
  // scales
  const plotX = (time)=> { return 40 + ((time - t0) / tWindow) * (w - 90); };
  const plotY = (x)=> { return 10 + (1 - x/roadMeters) * (h - 60); }; // top is downstream

  if (document.getElementById('showTimeSpace').checked) {
    vehicles.forEach(v => {
      const hist = v.history.filter(p => p.t >= t0);
      if (hist.length < 2) return;
      ctx.beginPath();
      // choose color by id
      const hue = (v.id * 37) % 360;
      ctx.strokeStyle = `hsl(${hue},60%,35%)`;
      ctx.lineWidth = 1.6;
      for (let i = 0; i < hist.length; i++) {
        const p = hist[i];
        const px = plotX(p.t);
        const py = plotY(p.x);
        if (i === 0) ctx.moveTo(px, py);
        else ctx.lineTo(px, py);
      }
      ctx.stroke();
    });
  } else {
    // show coarser time-space as density shading (not implemented for brevity)
    ctx.fillStyle = "#eee";
    ctx.fillRect(45,15, w-100, h-60);
  }

  // current sim time marker
  ctx.fillStyle = "#003049";
  ctx.fillText("t = " + Math.floor(simTime) + " s", w - 120, 20);
}

/* =========================
   update charts & stats
   ========================= */
function updateChartsAndStats() {
  const macros = computeMacros();

  // update stats
  document.getElementById('cumCount').textContent = cumulativeCount;
  document.getElementById('flowVal').textContent = Math.round(macros.flowDown);
  document.getElementById('densVal').textContent = (macros.totalDensity).toFixed(1);
  document.getElementById('speedVal').textContent = (macros.avgSpeedAllKmh).toFixed(1);

  // N-t chart (sample every second)
  ntChart.data.labels = NtTimes.slice(-200);
  ntChart.data.datasets[0].data = NtCounts.slice(-200);
  ntChart.update('none');

  // flow-density & speed-density: sample points from segments
  const fdPoints = [];
  const sdPoints = [];
  macros.segMacros.forEach(s => {
    // density (veh/km) and flow (veh/hr) -- approximate local flow using downstream flow for simplicity
    fdPoints.push({ x: s.density, y: macros.flowDown });
    sdPoints.push({ x: s.density, y: s.avgSpeedKmh });
  });
  fdScatter.data.datasets[0].data = fdPoints;
  fdScatter.update('none');

  sdScatter.data.datasets[0].data = sdPoints;
  sdScatter.update('none');
}

/* =========================
   Primary run loop
   ========================= */
function stepSim() {
  stepOnce();
  drawStaticRoad();
  drawVehicles();
  drawTimeSpace();
  updateChartsAndStats();
}

function runSim() {
  if (!running) return;
  stepSim();
  // schedule next (use setTimeout to keep dt ~ real seconds scaled)
  setTimeout(()=> { if (running) requestAnimationFrame(runSim); }, 1000 * (dt/1.0));
}

/* =========================
   Reset simulation
   ========================= */
function resetSim() {
  vehicles = [];
  simTime = 0;
  cumulativeCount = 0;
  NtTimes = [];
  NtCounts = [];
  lastId = 0;
  stepOnce.lastPassTime = -1e9;
  // insert a few warm vehicles
  for (let i=0;i<6;i++) {
    vehicles.push({ id: ++lastId, x: i*40 + 20, v: freeSpeedDefault, history: [{t:0,x:i*40 + 20}] });
  }
  drawStaticRoad();
  drawVehicles();
  drawTimeSpace();
  updateChartsAndStats();
}

/* =========================
   Initialize & draw first state
   ========================= */
resetSim();

/* initial drawing */
drawStaticRoad();
drawVehicles();
drawTimeSpace();
updateChartsAndStats();

</script>
</body>
</html>
